<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Advanced Charts with Markdown Data</title>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-boxplot"></script>
<style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .container {
            display: flex;
            width: 100%;
            max-width: 800px;
            height: 50%;
        }

        .chart-options {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 5px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .chart-options label {
            margin-bottom: 10px;
        }

        .axis-select {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
        }

        .chart-container {
            flex: 3;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .chart-container canvas {
            width: 100%;
            height: 100%;
        }

        .axis-dropdowns {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-center;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }

        .axis-dropdowns select {
            margin-bottom: 10px;
        }
    </style>
</head>

    <div class="container">
        <div class="chart-options">
            <label><input type="radio" name="chartType" value="line" checked> Line Chart</label>
            <label><input type="radio" name="chartType" value="bar"> Bar Chart</label>
            <label><input type="radio" name="chartType" value="pie"> Pie Chart</label>
            <label><input type="radio" name="chartType" value="scatter"> Scatter Plot</label>
            <label><input type="radio" name="chartType" value="histogram"> Histogram</label>
            <label><input type="radio" name="chartType" value="boxplot"> Box Plot</label>
            <!-- <label><input type="radio" name="chartType" value="area"> Area Chart</label> -->
            <label><input type="radio" name="chartType" value="bubble"> Bubble Chart</label>
            <label><input type="radio" name="chartType" value="pareto"> Pareto Chart</label>
            <label><input type="radio" name="chartType" value="waterfall"> Waterfall Chart</label>
        </div>
        <div class="chart-container">
            <canvas id="myChart" width="400" height="200"></canvas>
        </div>
        <div class="axis-dropdowns">
            <div class="axis-select">
                <label for="xAxisSelect">Select X-Axis: </label>
                <select id="xAxisSelect"></select>
                <label for="yAxisSelect">Select Y-Axis: </label>
                <select id="yAxisSelect"></select>
                <label for="zAxisSelect">Select Z-Axis: </label>
                <select id="zAxisSelect"></select>
            </div>
        </div>
    </div>
	
	
	<script>
	// Sample markdown table data
	const markdownTable = `
| Date       | Value1 | Value2 | Value3 |
|------------|--------|--------|--------|
| 2024-08-01 | 10     | 5      | 7      |
| 2024-08-02 | 15     | 8      | 14     |
| 2024-08-03 | 7      | 3      | 4      |
| 2024-08-04 | 12     | 9      | 6      |
| 2024-08-05 | 20     | 7      | 8      |
        `;
	// Function to parse markdown table
	function parseMarkdownTable(mdTable) {
		const rows = mdTable.trim().split('\n');
		const headers = rows[0].split('|').slice(1, -1).map(header => header.trim());
		const data = rows.slice(2).map(row => {
			const cells = row.split('|').slice(1, -1).map(cell => cell.trim());
			const rowObject = {};
			headers.forEach((header, index) => {
				rowObject[header] = isNaN(cells[index]) ? cells[index] : parseFloat(cells[index]);
			});
			return rowObject;
		});
		return {
			headers,
			data
		};
	}
	const {
		headers,
		data
	} = parseMarkdownTable(markdownTable);
	// Populate axis selection dropdowns with headers
	const xAxisSelect = document.getElementById('xAxisSelect');
	const yAxisSelect = document.getElementById('yAxisSelect');
	const zAxisSelect = document.getElementById('zAxisSelect');
	headers.forEach(header => {
		const optionX = document.createElement('option');
		optionX.value = header;
		optionX.text = header;
		xAxisSelect.appendChild(optionX);
		const optionY = document.createElement('option');
		optionY.value = header;
		optionY.text = header;
		yAxisSelect.appendChild(optionY);
		const optionZ = document.createElement('option');
		optionZ.value = header;
		optionZ.text = header;
		zAxisSelect.appendChild(optionZ);
	});
	// Set initial selections
	xAxisSelect.value = headers[0];
	yAxisSelect.value = headers[1];
	yAxisSelect.value = headers[2];
	let chartType = 'line';
	let myChart;
	const ctx = document.getElementById('myChart').getContext('2d');

	function createChart(type) {
		if(myChart) {
			myChart.destroy(); // Destroy previous chart before creating a new one
		}
		const xAxis = xAxisSelect.value;
		const yAxis = yAxisSelect.value;
		const zAxis = zAxisSelect.value;
		let datasets = [{
			label: `${yAxis} vs ${xAxis}`,
			data: data.map(item => ({
				x: item[xAxis],
				y: item[yAxis]
			})),
				fill: false, // change to true for area plot
				backgroundColor: 'rgba(75, 192, 192, 0.2)',
				borderColor: 'rgba(75, 192, 192, 1)',
				borderWidth: 1,
		}];
		if(type === 'pie') {
			datasets = [{
				label: yAxis,
				data: data.map(item => item[yAxis]),
				backgroundColor: ['rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 'rgba(75, 192, 192, 0.2)', 'rgba(153, 102, 255, 0.2)'],
				borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)'],
				borderWidth: 1,
			}];
		} else if(type === 'histogram') {
			datasets = [{
				label: yAxis,
				data: data.map(item => item[yAxis]),
				backgroundColor: 'rgba(75, 192, 192, 0.2)',
				borderColor: 'rgba(75, 192, 192, 1)',
				borderWidth: 1,
			}];
		} else if(type === 'boxplot') {
			datasets = [{
				label: yAxis,
				data: data.map(item => item[yAxis]),
				borderColor: 'rgba(255, 99, 132, 1)',
			}];
		} else if (chartType === 'area') {
			datasets = [{
				label: `${yAxis} vs ${xAxis}`,
				data: data.map(item => ({
					x: item[xAxis],
					y: item[yAxis]
				})),
				fill: true,
				backgroundColor: 'rgba(75, 191, 191, 0.2)',
				borderColor: 'rgba(75, 191, 191, 1)',
				borderWidth: 1,
			}];
		} else if(type === 'bubble') {
			datasets = [{
				label: `${yAxis} vs ${xAxis} Radius: ${zAxis}`,
				data: data.map(item => ({
					x: item[xAxis],
					y: item[yAxis],
					r: item[zAxis] || 5
				})),
				backgroundColor: 'rgba(75, 192, 192, 0.2)',
				borderColor: 'rgba(75, 192, 192, 1)',
				borderWidth: 1,
			}];
		} else if(type === 'pareto') {
			datasets = [{
				label: `${yAxis} (Bars)`,
				type: 'bar',
				data: data.map(item => item[yAxis]),
				backgroundColor: 'rgba(75, 192, 192, 0.2)',
				borderColor: 'rgba(75, 192, 192, 1)',
				borderWidth: 1,
			}, {
				label: 'Cumulative Percentage (Line)',
				type: 'line',
				data: data.map((item, index) => {
					const total = data.reduce((acc, curr) => acc + curr[yAxis], 0);
					const cumulative = data.slice(0, index + 1).reduce((acc, curr) => acc + curr[yAxis], 0);
					return (cumulative / total) * 100;
				}),
				borderColor: 'rgba(255, 99, 132, 1)',
				fill: false,
				borderWidth: 2,
			}];
		} else if(type === 'waterfall') {
			datasets = [{
				label: `${yAxis}`,
				data: data.map(item => item[yAxis]),
				backgroundColor: (ctx) => {
					const index = ctx.dataIndex;
					return index % 2 === 0 ? 'rgba(75, 192, 192, 0.2)' : 'rgba(255, 99, 132,0.2)';
				},
				borderColor: (ctx) => {
					const index = ctx.dataIndex;
					return index % 2 === 0 ? 'rgba(75, 192, 192, 1)' : 'rgba(255, 99, 132, 1)';
				},
				borderWidth: 1,
			}];
		}
		myChart = new Chart(ctx, {
			type: (type === 'histogram' || type === 'boxplot' || type === 'pareto' || type === 'waterfall') ? 'bar' : type,
			data: {
				labels: data.map(item => item[xAxis]),
				datasets: datasets
			},
			options: {
				scales: {
					x: {
						beginAtZero: true,
						title: {
							display: true,
							text: xAxis
						}
					},
					y: {
						beginAtZero: true,
						title: {
							display: true,
							text: yAxis
						}
					}
				}
			}
		});
	}
	document.querySelectorAll('input[name="chartType"]').forEach(input => {
		input.addEventListener('change', (event) => {
			chartType = event.target.value;
			createChart(chartType);
		});
	});
	xAxisSelect.addEventListener('change', () => createChart(chartType));
	yAxisSelect.addEventListener('change', () => createChart(chartType));
	// Initial chart rendering
	createChart(chartType);
	</script>