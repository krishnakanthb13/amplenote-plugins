---
title: TextMagiQ
uuid: afed7270-44f9-11ef-bdf6-26e37c279344
version: 197
created: '2024-07-18T17:04:26+05:30'
tags:
  - '-9-permanent'
  - '-loc/amp/mine'
---

# <mark style="color:#9AD62A;">Welcome Note:<!-- {"cycleColor":"26"} --></mark>

The Plugin provides a versatile tool for text transformation, supporting a wide array of transformations from simple case conversions to complex visual effects. By selecting your requirement, you can apply the desired transformation to any given text. This utility can be integrated into web applications for dynamic text manipulation, enhancing user experience with varied text formatting options.

---

## <mark style="color:#F8D616;">Initial Things TODO after installation:<!-- {"cycleColor":"25"} --></mark> 

- Nothing, You Can Start Using This Plugin Right Away!

- NOTHING, yOu cAn sTaRt UsiNg thIs PLugIN rIGht away!

---

## <mark style="color:#F8D616;">Demo:<!-- {"cycleColor":"25"} --></mark>

### <mark>General - Calling the Plugin - TextMagiQ</mark>

![](https://images.amplenote.com/afed7270-44f9-11ef-bdf6-26e37c279344/4ebfb802-e49d-4d8f-b574-f70d285edf97.gif)

---

## <mark style="color:#F8D616;">Documentation:<!-- {"cycleColor":"25"} --></mark>

### <mark style="color:#F8914D;">Text Transformation Utility Overview<!-- {"cycleColor":"24"} --></mark>

This Plugin, allows you to apply various transformations to a given text. It supports a wide range of transformations including different case conversions, special formatting, and visual effects. This document explains each transformation type and how it affects the input text.

## <mark style="color:#F8D616;">Transformation Types<!-- {"cycleColor":"25"} --></mark>

### <mark style="color:#9AD62A;">1. `sentence_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world. this is a test."

- <mark style="color:#F8D616;">**Output**: "Hello world. This is a test."<!-- {"cycleColor":"25"} --></mark>

- **Description**: The sentence case converter will allow you to paste any text you’d like, and it will automatically transform it to a fully formed structured sentence. It works by capitalizing the very first letter in each sentence, and will then go on to transform the rest of the text into lowercase as well as converting i’s into I’s. Every letter after a full stop will get converted into an upper case letter.

### <mark style="color:#9AD62A;">2. `lower_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "Hello World!"

- <mark style="color:#F8D616;">**Output**: "hello world!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: If you are wondering how to uncapitalize text, this is exactly what the lower case text converter will allow you to do - it transforms all the letters in your text into lowercase letters.

### <mark style="color:#9AD62A;">3. `upper_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "Hello World!"

- <mark style="color:#F8D616;">**Output**: "HELLO WORLD!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: The upper case transformer will take any text that you have and will generate all the letters into upper case ones. It will essentially make all lower case letters into CAPITALS (as well as keep upper case letters as upper case letters).

### <mark style="color:#9AD62A;">4. `capitalized_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world!"

- <mark style="color:#F8D616;">**Output**: "Hello World!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: The capitalized case converter will automatically convert the starting letter of every word into an upper case and will leave the remaining letters as lower case ones.

### <mark style="color:#9AD62A;">5. `alternating_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world!"

- <mark style="color:#F8D616;">**Output**: "hElLo wOrLd!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: The alternating case converter will allow you to transform your text (no matter the current format) into text that alternates between lower case and upper case. It will generate a capital letter and then a lower case letter within the same word.

### <mark style="color:#9AD62A;">6. `title_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world, this is a test."

- <mark style="color:#F8D616;">**Output**: "Hello World, This Is a Test."<!-- {"cycleColor":"25"} --></mark>

- **Description**: The title case converter is perfect for those who are a bit unsure on how to title an upcoming essay. It essentially ensures the correct letters are capitalized within the context of a title. Words such as “an” will be left all in lower case and words that are important will be converted such as “Title”.

### <mark style="color:#9AD62A;">7. `inverse_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "Hello World!"

- <mark style="color:#F8D616;">**Output**: "hELLO wORLD!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Inverts the case of each character in the text.

### <mark style="color:#9AD62A;">8. `random_case`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world!"

- <mark style="color:#F8D616;">**Output**: "HeLLo WoRLd!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Randomly changes the case of each character.

### <mark style="color:#9AD62A;">9. `small_caps`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world!"

- <mark style="color:#F8D616;">**Output**: "ʜᴇʟʟᴏ ᴡᴏʀʟᴅ!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: The small text generator simply takes regular sized text and converts it into small text (specifically “small caps” as well as “Superscript” text. Write out your normal text and see it get converted into the small text font.

### <mark style="color:#9AD62A;">10. `superscript`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello world!"

- <mark style="color:#F8D616;">**Output**: "ʰᵉˡˡᵒ ʷᵒʳˡᵈ!"<!-- {"cycleColor":"25"} --></mark>

- **Description**: The small text generator simply takes regular sized text and converts it into small text (specifically “small caps” as well as “Superscript” text. Write out your normal text and see it get converted into the small text font.

### <mark style="color:#9AD62A;">11. `wide_text`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "ｈｅｌｌｏ"<!-- {"cycleColor":"25"} --></mark>

- **Description**: If you are looking to widen the look of your text, the widening text generator is great for this, otherwise known as the Aesthetic Font and text generator. Simply type your normal text and see it get wider and wider.

### <mark style="color:#9AD62A;">12. `reverse_text`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "olleh"<!-- {"cycleColor":"25"} --></mark>

- **Description**: If you want a fast and quick way of making your text go back to front, the reverse text generator is great. Write out your text like normal and then see it get flipped.

### <mark style="color:#9AD62A;">13. `upside_down_text`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "ollǝɥ"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Similar to the mirror text generator as well as the reverse text generator, you can flip your text upside down as well as back to front with the upside down text generator.

### <mark style="color:#9AD62A;">14. `morse_code_translate`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: ".... . .-.. .-.. ---"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Converts text to Morse code. Whether you are looking to translate Morse code messages into simple English or the other way around, this online translation generator can do just that.

### <mark style="color:#9AD62A;">15. `morse_code_reverse`<!-- {"cycleColor":"26"} --></mark>

- **Input**: ".... . .-.. .-.. ---"

- <mark style="color:#F8D616;">**Output**: "hello"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Converts Morse code back to text. Whether you are looking to translate Morse code messages into simple English or the other way around, this online translation generator can do just that.

### <mark style="color:#9AD62A;">16. `binary_translate`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "01101000 01100101 01101100 01101100 01101111"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Converts text to binary representation. Translate binary code into English and English into binary code with the following generator. Type out regularly and get a series of 0’s and 1’s in return.

### <mark style="color:#9AD62A;">17. `binary_reverse`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "01101000 01100101 01101100 01101100 01101111"

- <mark style="color:#F8D616;">**Output**: "hello"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Converts binary representation back to text. Translate binary code into English and English into binary code with the following generator. Type out regularly and get a series of 0’s and 1’s in return.

### <mark style="color:#9AD62A;">18. `mirror_text`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "olleh"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Converts text to a mirrored format. The mirror text is basically the exact same text that you would get when you have your text facing a mirror. Print out the text and hold it up to a mirror and it should read the correct way.

### <mark style="color:#9AD62A;">19. `zalgo_text`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "h̸͠e̴̾l̷̈́l̷͠o̶̕"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Adds Zalgo text effects, creating a glitchy appearance. Want to produce funky and glitchy text? \`This Zalgo text will do just that. Type out what you would normally want to and then see it get turned into the Zalgo font.

### <mark style="color:#9AD62A;">20. `circled`<!-- {"cycleColor":"26"} --></mark>

- **Input**: "hello"

- <mark style="color:#F8D616;">**Output**: "ⓗⓔⓛⓛⓞ"<!-- {"cycleColor":"25"} --></mark>

- **Description**: Converts text to circled format using Unicode characters.

---

## <mark style="color:#F8D616;">Table - Plugin Parameters:<!-- {"cycleColor":"25"} --></mark>

| | |
|-|-|
|name<!-- {"cell":{"colwidth":116}} -->|TextMagiQ<!-- {"cell":{"colwidth":572}} -->|
|icon<!-- {"cell":{"colwidth":116}} -->|text_fields<!-- {"cell":{"colwidth":572}} -->|
|description<!-- {"cell":{"colwidth":116}} -->|Different types Case Formatting, Generating and Translating Options. This can separated into 6 Groups, namely - Case, Special, Flip, Code, Visual, and Unicode!<!-- {"cell":{"colwidth":572}} -->|
|instructions|Please fine the Instructions here =  [TextMagiQ Docs](https://www.amplenote.com/notes/b5a5e892-44e9-11ef-bdf6-26e37c279344) |
---

## <mark style="color:#F8D616;">Code Base:<!-- {"cycleColor":"25"} --></mark>

```
(() => {
    // Function to transform text based on the specified transformation type
    function transformText(text, transformType) {
        switch (transformType) {
            case 'sentence_case':
                // Convert to sentence case: First letter of each sentence capitalized
                return text.toLowerCase().replace(/(^\s*\w|[\.\!\?]\s*\w)/g, c => c.toUpperCase());
            case 'lower_case':
                // Convert to lower case
                return text.toLowerCase();
            case 'upper_case':
                // Convert to upper case
                return text.toUpperCase();
            case 'capitalized_case':
                // Convert to capitalized case: First letter of each word capitalized
                return text.toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
            case 'alternating_case':
                // Convert to alternating case: Alternate between lower and upper case
                return text.split('').map((c, i) => i % 2 === 0 ? c.toLowerCase() : c.toUpperCase()).join('');
            case 'title_case':
                // Convert to title case: First letter of each major word capitalized
                return text.toLowerCase().replace(/\b(?:an?|the|and|or|but|for|nor|on|at|to|by|with|about|of)\b|\b\w/g, c => c.toUpperCase());
            case 'inverse_case':
                // Convert to inverse case: Lowercase letters to uppercase and vice versa
                return text.split('').map(c => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase()).join('');
            case 'random_case':
                // Convert to random case: Randomly change case of each letter
                return text.split('').map(c => Math.random() < 0.5 ? c.toLowerCase() : c.toUpperCase()).join('');
            case 'small_caps':
                // Convert to small caps (custom function)
                return convertToSmallCaps(text);
            case 'superscript2':
                // Convert to superscript (custom function)
                return convertToSuperscript(text);
            case 'wide_text':
                // Convert to wide text (custom function)
                return convertToWideText(text);
            case 'reverse_text':
                // Reverse the text
                return reverseText(text);
            case 'upside_down_text':
                // Flip text upside down (custom function)
                return flipUpsideDown(text);
            case 'morse_code_translate':
                // Convert text to Morse code (custom function)
                return textToMorse(text);
            case 'morse_code_reverse':
                // Convert Morse code to text (custom function)
                return morseToText(text);
            case 'binary_translate':
                // Convert text to binary (custom function)
                return textToBinary(text);
            case 'binary_reverse':
                // Convert binary to text (custom function)
                return binaryToText(text);
            case 'mirror_text':
                // Convert text to mirror text (custom function)
                return mirrorText(text);
            case 'zalgo_text':
                // Convert text to Zalgo text (custom function)
                return zalgoText(text);
            case 'bold':
                // Make text bold
                return `**${text}**`;
            case 'italic':
                // Make text italic
                return `*${text}*`;
            case 'strikethrough':
                // Strike through the text
                return `~~${text}~~`;
            case 'underline':
                // Underline the text
                return `<u>${text}</u>`;
            case 'blockquote':
                // blockquote the text
                return `> ${text}`;
            case 'code':
                // code block the text
                return `\`${text}\``;
            case 'subscript':
                // Subscript the text
                return `~${text}~`;
            case 'superscript':
                // Superscript the text
                return `^${text}^`;
            case 'fraktur':
                // Convert to Fraktur script (custom function)
                return convertToFraktur(text);
            case 'fraktur_bold':
                // Convert to bold Fraktur script (custom function)
                return convertToFrakturBold(text);
            case 'squared':
                // Convert to squared text (custom function)
                return convertToSquared(text);
            case 'squared_inverted':
                // Convert to squared inverted text (custom function)
                return convertToSquaredInverted(text);
            case 'circled':
                // Convert to circled text (custom function)
                return convertToCircled(text);
            case 'circled_inverted':
                // Convert to circled inverted text (custom function)
                return convertToCircledInverted(text);
            default:
                // Return original text if no transformation type matches
                return text;
        }
    }

// Convert text to squared characters
function convertToSquared(text) {
    const squaredMap = {
        'A': '\u1D400',
        'B': '\u1D401',
        'C': '\u1D402',
        'D': '\u1D403',
        'E': '\u1D404',
        'F': '\u1D405',
        'G': '\u1D406',
        'H': '\u1D407',
        'I': '\u1D408',
        'J': '\u1D409',
        'K': '\u1D40A',
        'L': '\u1D40B',
        'M': '\u1D40C',
        'N': '\u1D40D',
        'O': '\u1D40E',
        'P': '\u1D40F',
        'Q': '\u1D410',
        'R': '\u1D411',
        'S': '\u1D412',
        'T': '\u1D413',
        'U': '\u1D414',
        'V': '\u1D415',
        'W': '\u1D416',
        'X': '\u1D417',
        'Y': '\u1D418',
        'Z': '\u1D419',
        'a': '\u1D41A',
        'b': '\u1D41B',
        'c': '\u1D41C',
        'd': '\u1D41D',
        'e': '\u1D41E',
        'f': '\u1D41F',
        'g': '\u1D420',
        'h': '\u1D421',
        'i': '\u1D422',
        'j': '\u1D423',
        'k': '\u1D424',
        'l': '\u1D425',
        'm': '\u1D426',
        'n': '\u1D427',
        'o': '\u1D428',
        'p': '\u1D429',
        'q': '\u1D42A',
        'r': '\u1D42B',
        's': '\u1D42C',
        't': '\u1D42D',
        'u': '\u1D42E',
        'v': '\u1D42F',
        'w': '\u1D430',
        'x': '\u1D431',
        'y': '\u1D432',
        'z': '\u1D433'
    };

    return Array.from(text).map(char => squaredMap[char] || char).join('');
}

// Convert text to squared inverted characters
function convertToSquaredInverted(text) {
    const squaredInvertedMap = {
        'A': '\u1D7D8',
        'B': '\u1D7D9',
        'C': '\u1D7DA',
        'D': '\u1D7DB',
        'E': '\u1D7DC',
        'F': '\u1D7DD',
        'G': '\u1D7DE',
        'H': '\u1D7DF',
        'I': '\u1D7E0',
        'J': '\u1D7E1',
        'K': '\u1D7E2',
        'L': '\u1D7E3',
        'M': '\u1D7E4',
        'N': '\u1D7E5',
        'O': '\u1D7E6',
        'P': '\u1D7E7',
        'Q': '\u1D7E8',
        'R': '\u1D7E9',
        'S': '\u1D7EA',
        'T': '\u1D7EB',
        'U': '\u1D7EC',
        'V': '\u1D7ED',
        'W': '\u1D7EE',
        'X': '\u1D7EF',
        'Y': '\u1D7F0',
        'Z': '\u1D7F1',
        'a': '\u1D7F2',
        'b': '\u1D7F3',
        'c': '\u1D7F4',
        'd': '\u1D7F5',
        'e': '\u1D7F6',
        'f': '\u1D7F7',
        'g': '\u1D7F8',
        'h': '\u1D7F9',
        'i': '\u1D7FA',
        'j': '\u1D7FB',
        'k': '\u1D7FC',
        'l': '\u1D7FD',
        'm': '\u1D7FE',
        'n': '\u1D7FF',
        'o': '\u1D800',
        'p': '\u1D801',
        'q': '\u1D802',
        'r': '\u1D803',
        's': '\u1D804',
        't': '\u1D805',
        'u': '\u1D806',
        'v': '\u1D807',
        'w': '\u1D808',
        'x': '\u1D809',
        'y': '\u1D80A',
        'z': '\u1D80B'
    };

    return Array.from(text).map(char => squaredInvertedMap[char] || char).join('');
}

// Convert text to circled characters
function convertToCircled(text) {
    const circledMap = {
        'A': '\u24B6',
        'B': '\u24B7',
        'C': '\u24B8',
        'D': '\u24B9',
        'E': '\u24BA',
        'F': '\u24BB',
        'G': '\u24BC',
        'H': '\u24BD',
        'I': '\u24BE',
        'J': '\u24BF',
        'K': '\u24C0',
        'L': '\u24C1',
        'M': '\u24C2',
        'N': '\u24C3',
        'O': '\u24C4',
        'P': '\u24C5',
        'Q': '\u24C6',
        'R': '\u24C7',
        'S': '\u24C8',
        'T': '\u24C9',
        'U': '\u24CA',
        'V': '\u24CB',
        'W': '\u24CC',
        'X': '\u24CD',
        'Y': '\u24CE',
        'Z': '\u24CF',
        'a': '\u24D0',
        'b': '\u24D1',
        'c': '\u24D2',
        'd': '\u24D3',
        'e': '\u24D4',
        'f': '\u24D5',
        'g': '\u24D6',
        'h': '\u24D7',
        'i': '\u24D8',
        'j': '\u24D9',
        'k': '\u24DA',
        'l': '\u24DB',
        'm': '\u24DC',
        'n': '\u24DD',
        'o': '\u24DE',
        'p': '\u24DF',
        'q': '\u24E0',
        'r': '\u24E1',
        's': '\u24E2',
        't': '\u24E3',
        'u': '\u24E4',
        'v': '\u24E5',
        'w': '\u24E6',
        'x': '\u24E7',
        'y': '\u24E8',
        'z': '\u24E9'
    };

    return Array.from(text).map(char => circledMap[char] || char).join('');
}

  // Convert text to circled inverted characters
function convertToCircledInverted(text) {
    const circledInvertedMap = {
        'A': '\u24B6',
        'B': '\u24B7',
        'C': '\u24B8',
        'D': '\u24B9',
        'E': '\u24BA',
        'F': '\u24BB',
        'G': '\u24BC',
        'H': '\u24BD',
        'I': '\u24BE',
        'J': '\u24BF',
        'K': '\u24C0',
        'L': '\u24C1',
        'M': '\u24C2',
        'N': '\u24C3',
        'O': '\u24C4',
        'P': '\u24C5',
        'Q': '\u24C6',
        'R': '\u24C7',
        'S': '\u24C8',
        'T': '\u24C9',
        'U': '\u24CA',
        'V': '\u24CB',
        'W': '\u24CC',
        'X': '\u24CD',
        'Y': '\u24CE',
        'Z': '\u24CF',
        'a': '\u24D0',
        'b': '\u24D1',
        'c': '\u24D2',
        'd': '\u24D3',
        'e': '\u24D4',
        'f': '\u24D5',
        'g': '\u24D6',
        'h': '\u24D7',
        'i': '\u24D8',
        'j': '\u24D9',
        'k': '\u24DA',
        'l': '\u24DB',
        'm': '\u24DC',
        'n': '\u24DD',
        'o': '\u24DE',
        'p': '\u24DF',
        'q': '\u24E0',
        'r': '\u24E1',
        's': '\u24E2',
        't': '\u24E3',
        'u': '\u24E4',
        'v': '\u24E5',
        'w': '\u24E6',
        'x': '\u24E7',
        'y': '\u24E8',
        'z': '\u24E9'
    };

    return Array.from(text).map(char => circledInvertedMap[char] || char).join('');
}

  // Convert text to fraktur characters
function convertToFraktur(text) {
    const frakturMap = {
        'A': '\uD835\uDD38',
        'B': '\uD835\uDD39',
        'C': '\uD835\uDD3A',
        'D': '\uD835\uDD3B',
        'E': '\uD835\uDD3C',
        'F': '\uD835\uDD3D',
        'G': '\uD835\uDD3E',
        'H': '\uD835\uDD3F',
        'I': '\uD835\uDD40',
        'J': '\uD835\uDD41',
        'K': '\uD835\uDD42',
        'L': '\uD835\uDD43',
        'M': '\uD835\uDD44',
        'N': '\uD835\uDD45',
        'O': '\uD835\uDD46',
        'P': '\uD835\uDD47',
        'Q': '\uD835\uDD48',
        'R': '\uD835\uDD49',
        'S': '\uD835\uDD4A',
        'T': '\uD835\uDD4B',
        'U': '\uD835\uDD4C',
        'V': '\uD835\uDD4D',
        'W': '\uD835\uDD4E',
        'X': '\uD835\uDD4F',
        'Y': '\uD835\uDD50',
        'Z': '\uD835\uDD51',
        'a': '\uD835\uDD52',
        'b': '\uD835\uDD53',
        'c': '\uD835\uDD54',
        'd': '\uD835\uDD55',
        'e': '\uD835\uDD56',
        'f': '\uD835\uDD57',
        'g': '\uD835\uDD58',
        'h': '\uD835\uDD59',
        'i': '\uD835\uDD5A',
        'j': '\uD835\uDD5B',
        'k': '\uD835\uDD5C',
        'l': '\uD835\uDD5D',
        'm': '\uD835\uDD5E',
        'n': '\uD835\uDD5F',
        'o': '\uD835\uDD60',
        'p': '\uD835\uDD61',
        'q': '\uD835\uDD62',
        'r': '\uD835\uDD63',
        's': '\uD835\uDD64',
        't': '\uD835\uDD65',
        'u': '\uD835\uDD66',
        'v': '\uD835\uDD67',
        'w': '\uD835\uDD68',
        'x': '\uD835\uDD69',
        'y': '\uD835\uDD6A',
        'z': '\uD835\uDD6B'
    };

    return text.split('').map(char => frakturMap[char] || char).join('');
}

  // Convert text to Fraktur Bold characters
function convertToFrakturBold(text) {
    const frakturBoldMap = {
        'A': '\uD835\uDD70',
        'B': '\uD835\uDD71',
        'C': '\uD835\uDD72',
        'D': '\uD835\uDD73',
        'E': '\uD835\uDD74',
        'F': '\uD835\uDD75',
        'G': '\uD835\uDD76',
        'H': '\uD835\uDD77',
        'I': '\uD835\uDD78',
        'J': '\uD835\uDD79',
        'K': '\uD835\uDD7A',
        'L': '\uD835\uDD7B',
        'M': '\uD835\uDD7C',
        'N': '\uD835\uDD7D',
        'O': '\uD835\uDD7E',
        'P': '\uD835\uDD7F',
        'Q': '\uD835\uDD80',
        'R': '\uD835\uDD81',
        'S': '\uD835\uDD82',
        'T': '\uD835\uDD83',
        'U': '\uD835\uDD84',
        'V': '\uD835\uDD85',
        'W': '\uD835\uDD86',
        'X': '\uD835\uDD87',
        'Y': '\uD835\uDD88',
        'Z': '\uD835\uDD89',
        'a': '\uD835\uDD8A',
        'b': '\uD835\uDD8B',
        'c': '\uD835\uDD8C',
        'd': '\uD835\uDD8D',
        'e': '\uD835\uDD8E',
        'f': '\uD835\uDD8F',
        'g': '\uD835\uDD90',
        'h': '\uD835\uDD91',
        'i': '\uD835\uDD92',
        'j': '\uD835\uDD93',
        'k': '\uD835\uDD94',
        'l': '\uD835\uDD95',
        'm': '\uD835\uDD96',
        'n': '\uD835\uDD97',
        'o': '\uD835\uDD98',
        'p': '\uD835\uDD99',
        'q': '\uD835\uDD9A',
        'r': '\uD835\uDD9B',
        's': '\uD835\uDD9C',
        't': '\uD835\uDD9D',
        'u': '\uD835\uDD9E',
        'v': '\uD835\uDD9F',
        'w': '\uD835\uDDA0',
        'x': '\uD835\uDDA1',
        'y': '\uD835\uDDA2',
        'z': '\uD835\uDDA3'
    };

    return Array.from(text).map(char => frakturBoldMap[char] || char).join('');
}

    // Convert text to zalgo characters
function zalgoText(text) {
    const zalgoChars = [
        '\u030d', '\u030e', '\u0304', '\u0305', '\u033f', '\u0311', '\u0306', '\u0310',
        '\u0352', '\u0357', '\u0351', '\u0307', '\u0308', '\u030a', '\u0342', '\u0343',
        '\u0344', '\u034a', '\u034b', '\u034c', '\u0303', '\u0302', '\u030c', '\u0350',
        '\u0300', '\u0301', '\u030b', '\u030f', '\u0312', '\u0313', '\u0314', '\u033d',
        '\u0309', '\u0363', '\u0364', '\u0365', '\u0366', '\u0367', '\u0368', '\u0369',
        '\u036a', '\u036b', '\u036c', '\u036d', '\u036e', '\u036f', '\u033e', '\u035b'
    ];

    function getRandomZalgo() {
        const rand = Math.floor(Math.random() * zalgoChars.length);
        return zalgoChars[rand];
    }

    //return text.split('').map(char => char + getRandomZalgo()).join('');
    // increase the level of craziness where i < (number)
    return text.split('').map(char => {
        let crazyChar = char;
        for (let i = 0; i < 4; i++) {
            crazyChar += getRandomZalgo();
        }
        return crazyChar;
    }).join('');
}
  
// Convert text to mirrorText characters
function mirrorText(text) {
    const mirrorMap = {
        'a': 'ɒ', 'b': 'd', 'c': 'ɔ', 'd': 'b', 'e': 'ɘ', 'f': 'ɟ', 'g': 'ƃ', 'h': 'ɥ', 'i': 'ı', 'j': 'ſ', 'k': 'ʞ',
        'l': 'l', 'm': 'ɯ', 'n': 'u', 'o': 'o', 'p': 'q', 'q': 'p', 'r': 'ɹ', 's': 's', 't': 'ʇ', 'u': 'n', 'v': 'ʌ',
        'w': 'ʍ', 'x': 'x', 'y': 'ʎ', 'z': 'z',
        'A': '∀', 'B': 'B', 'C': 'Ɔ', 'D': 'D', 'E': 'Ǝ', 'F': 'Ⅎ', 'G': '⅁', 'H': 'H', 'I': 'I', 'J': 'ſ', 'K': 'K',
        'L': '⅂', 'M': 'W', 'N': 'N', 'O': 'O', 'P': 'Ԁ', 'Q': 'Q', 'R': 'ᴚ', 'S': 'S', 'T': '⊥', 'U': '∩', 'V': 'Λ',
        'W': 'M', 'X': 'X', 'Y': '⅄', 'Z': 'Z',
        '0': '0', '1': 'Ɩ', '2': 'ᄅ', '3': 'Ɛ', '4': 'ㄣ', '5': 'ϛ', '6': '9', '7': 'ㄥ', '8': '8', '9': '6',
        '.': '˙', ',': "'", '?': '¿', '\'': ',', '!': '¡',
        '(': ')', ')': '(', '{': '}', '}': '{', '[': ']', ']': '[', '<': '>', '>': '<', '/': '\\', '\\': '/',
        '&': '⅋', '_': '‾', '"': '``', '`': '"', ';': '؛', ':': ':', '^': 'v', 'v': '^', '@': '@', '#': '#', '$': '$',
        '%': '%', '*': '*', '+': '+', '-': '-', '=': '=', '~': '~'
    };

    return text.split('').reverse().map(char => mirrorMap[char] || char).join('');
}
  
// Convert text to textToBinary characters
function textToBinary(text) {
    return text.split('').map(char => char.charCodeAt(0).toString(2)).join(' ');
}
  
// Convert text to binaryToText characters
function binaryToText(binary) {
    return binary.split(' ').map(bin => String.fromCharCode(parseInt(bin, 2))).join('');
}
  
// Convert text to textToMorse characters
function textToMorse(text) {
    const morseMap = {
        'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---',
        'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-',
        'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..',
        '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',
        '6': '-....', '7': '--...', '8': '---..', '9': '----.',
        '.': '.-.-.-', ',': '--..--', '?': '..--..', '\'': '.----.', '!': '-.-.--',
        '/': '-..-.', '(': '-.--.', ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.',
        '=': '-...-', '+': '.-.-.', '-': '-....-', '_': '..--.-', '"': '.-..-.', '$': '...-..-',
        '@': '.--.-.'
    };

    return text.toLowerCase().split('').map(c => morseMap[c] || '').join(' ');
}
  
// Convert text to morseToText characters
function morseToText(text) {
    const morseReverseMap = {
        '.-': 'a', '-...': 'b', '-.-.': 'c', '-..': 'd', '.': 'e', '..-.': 'f', '--.': 'g', '....': 'h', '..': 'i', '.---': 'j',
        '-.-': 'k', '.-..': 'l', '--': 'm', '-.': 'n', '---': 'o', '.--.': 'p', '--.-': 'q', '.-.': 'r', '...': 's', '-': 't',
        '..-': 'u', '...-': 'v', '.--': 'w', '-..-': 'x', '-.--': 'y', '--..': 'z',
        '-----': '0', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5',
        '-....': '6', '--...': '7', '---..': '8', '----.': '9',
        '.-.-.-': '.', '--..--': ',', '..--..': '?', '.----.': '\'', '-.-.--': '!',
        '-..-.': '/', '-.--.': '(', '-.--.-': ')', '.-...': '&', '---...': ':', '-.-.-.': ';',
        '-...-': '=', '.-.-.': '+', '-....-': '-', '..--.-': '_', '.-..-.': '"', '...-..-': '$',
        '.--.-.': '@'
    };

    return text.split(' ').map(m => morseReverseMap[m] || '').join('');
}
  
// Convert text to flipUpsideDown characters
function flipUpsideDown(text) {
    const upsideDownMap = {
        'a': 'ɐ', 'b': 'q', 'c': 'ɔ', 'd': 'p', 'e': 'ǝ', 'f': 'ɟ', 'g': 'ƃ', 'h': 'ɥ', 'i': 'ᴉ',
        'j': 'ɾ', 'k': 'ʞ', 'l': 'l', 'm': 'ɯ', 'n': 'u', 'o': 'o', 'p': 'd', 'q': 'b', 'r': 'ɹ',
        's': 's', 't': 'ʇ', 'u': 'n', 'v': 'ʌ', 'w': 'ʍ', 'x': 'x', 'y': 'ʎ', 'z': 'z',
        'A': '∀', 'B': 'q', 'C': 'Ɔ', 'D': 'p', 'E': 'Ǝ', 'F': 'Ⅎ', 'G': 'פ', 'H': 'H', 'I': 'I',
        'J': 'ſ', 'K': 'ʞ', 'L': '˥', 'M': 'W', 'N': 'N', 'O': 'O', 'P': 'Ԁ', 'Q': 'Q', 'R': 'ᴚ',
        'S': 'S', 'T': '⊥', 'U': '∩', 'V': 'Λ', 'W': 'M', 'X': 'X', 'Y': '⅄', 'Z': 'Z',
        '0': '0', '1': 'Ɩ', '2': 'ᄅ', '3': 'Ɛ', '4': 'ㄣ', '5': 'ϛ', '6': '9', '7': 'ㄥ', '8': '8', '9': '6',
        '!': '¡', '?': '¿', '+': '+', '-': '-', '=': '=', '*': '*', '%': '%', '$': '$', '&': '⅋', '#': '#',
        '@': '@', '^': '^', '(': ')', ')': '(', '[': ']', ']': '[', '{': '}', '}': '{', '<': '>', '>': '<',
        '/': '/', '|': '|', '\\': '\\', '~': '~', '`': '`', ',': "'", '.': '.', ':': ':', ';': ';', '\'': ',',
        '"': '"', '_': '_', ' ': ' '
    };

    return text.split('').reverse().map(c => upsideDownMap[c] || c).join('');
}

// Convert text to reverseText characters
function reverseText(text) {
    return text.split('').reverse().join('');
}
  
// Convert text to convertToWideText characters
function convertToWideText(text) {
    const wideMap = {
        'a': 'ａ', 'b': 'ｂ', 'c': 'ｃ', 'd': 'ｄ', 'e': 'ｅ', 'f': 'ｆ', 'g': 'ｇ', 'h': 'ｈ', 'i': 'ｉ',
        'j': 'ｊ', 'k': 'ｋ', 'l': 'ｌ', 'm': 'ｍ', 'n': 'ｎ', 'o': 'ｏ', 'p': 'ｐ', 'q': 'ｑ', 'r': 'ｒ',
        's': 'ｓ', 't': 'ｔ', 'u': 'ｕ', 'v': 'ｖ', 'w': 'ｗ', 'x': 'ｘ', 'y': 'ｙ', 'z': 'ｚ',
        'A': 'Ａ', 'B': 'Ｂ', 'C': 'Ｃ', 'D': 'Ｄ', 'E': 'Ｅ', 'F': 'Ｆ', 'G': 'Ｇ', 'H': 'Ｈ', 'I': 'Ｉ',
        'J': 'Ｊ', 'K': 'Ｋ', 'L': 'Ｌ', 'M': 'Ｍ', 'N': 'Ｎ', 'O': 'Ｏ', 'P': 'Ｐ', 'Q': 'Ｑ', 'R': 'Ｒ',
        'S': 'Ｓ', 'T': 'Ｔ', 'U': 'Ｕ', 'V': 'Ｖ', 'W': 'Ｗ', 'X': 'Ｘ', 'Y': 'Ｙ', 'Z': 'Ｚ',
        '0': '０', '1': '１', '2': '２', '3': '３', '4': '４', '5': '５', '6': '６', '7': '７', '8': '８', '9': '９',
        '!': '！', '?': '？', '+': '＋', '-': '－', '=': '＝', '*': '＊', '%': '％', '$': '＄', '&': '＆', '#': '＃',
        '@': '＠', '^': '＾', '(': '（', ')': '）', '[': '［', ']': '］', '{': '｛', '}': '｝', '<': '＜', '>': '＞',
        '/': '／', '|': '｜', '\\': '＼', '~': '～', '`': '｀', ',': '，', '.': '．', ':': '：', ';': '；', '\'': '＇',
        '"': '＂', '_': '＿', ' ': '　'
    };

    return text.split('').map(c => wideMap[c] || c).join('');
}
  
// Convert text to convertToSmallCaps characters
function convertToSmallCaps(text) {
    const smallCapsMap = {
        'a': 'ᴀ', 'b': 'ʙ', 'c': 'ᴄ', 'd': 'ᴅ', 'e': 'ᴇ', 'f': 'ꜰ', 'g': 'ɢ', 'h': 'ʜ', 'i': 'ɪ',
        'j': 'ᴊ', 'k': 'ᴋ', 'l': 'ʟ', 'm': 'ᴍ', 'n': 'ɴ', 'o': 'ᴏ', 'p': 'ᴘ', 'q': 'Q', 'r': 'ʀ',
        's': 'ꜱ', 't': 'ᴛ', 'u': 'ᴜ', 'v': 'ᴠ', 'w': 'ᴡ', 'x': 'X', 'y': 'ʏ', 'z': 'ᴢ',
        'A': 'ᴀ', 'B': 'ʙ', 'C': 'ᴄ', 'D': 'ᴅ', 'E': 'ᴇ', 'F': 'ꜰ', 'G': 'ɢ', 'H': 'ʜ', 'I': 'ɪ',
        'J': 'ᴊ', 'K': 'ᴋ', 'L': 'ʟ', 'M': 'ᴍ', 'N': 'ɴ', 'O': 'ᴏ', 'P': 'ᴘ', 'Q': 'Q', 'R': 'ʀ',
        'S': 'ꜱ', 'T': 'ᴛ', 'U': 'ᴜ', 'V': 'ᴠ', 'W': 'ᴡ', 'X': 'X', 'Y': 'ʏ', 'Z': 'ᴢ',
    };

    return text.split('').map(c => smallCapsMap[c] || c).join('');
}
  
// Convert text to convertToSmallCaps characters
function convertToSuperscript(text) {
    const superscriptMap = {
        'a': 'ᵃ', 'b': 'ᵇ', 'c': 'ᶜ', 'd': 'ᵈ', 'e': 'ᵉ', 'f': 'ᶠ', 'g': 'ᵍ', 'h': 'ʰ', 'i': 'ⁱ',
        'j': 'ʲ', 'k': 'ᵏ', 'l': 'ˡ', 'm': 'ᵐ', 'n': 'ⁿ', 'o': 'ᵒ', 'p': 'ᵖ', 'q': 'ᑫ', 'r': 'ʳ',
        's': 'ˢ', 't': 'ᵗ', 'u': 'ᵘ', 'v': 'ᵛ', 'w': 'ʷ', 'x': 'ˣ', 'y': 'ʸ', 'z': 'ᶻ',
        'A': 'ᴬ', 'B': 'ᴮ', 'C': 'ᶜ', 'D': 'ᴰ', 'E': 'ᴱ', 'F': 'ᶠ', 'G': 'ᴳ', 'H': 'ᴴ', 'I': 'ᴵ',
        'J': 'ᴶ', 'K': 'ᴷ', 'L': 'ᴸ', 'M': 'ᴹ', 'N': 'ᴺ', 'O': 'ᴼ', 'P': 'ᴾ', 'Q': 'ᑫ', 'R': 'ᴿ',
        'S': 'ˢ', 'T': 'ᵀ', 'U': 'ᵁ', 'V': 'ⱽ', 'W': 'ᵂ', 'X': 'ˣ', 'Y': 'ʸ', 'Z': 'ᶻ',
        '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹',
        '+': '⁺', '-': '⁻', '=': '⁼', '(': '⁽', ')': '⁾', 'a': 'ᵃ', 'b': 'ᵇ', 'c': 'ᶜ', 'd': 'ᵈ', 'e': 'ᵉ', 'f': 'ᶠ', 'g': 'ᵍ', 'h': 'ʰ', 'i': 'ⁱ',
        'j': 'ʲ', 'k': 'ᵏ', 'l': 'ˡ', 'm': 'ᵐ', 'n': 'ⁿ', 'o': 'ᵒ', 'p': 'ᵖ', 'q': 'ᑫ', 'r': 'ʳ',
        's': 'ˢ', 't': 'ᵗ', 'u': 'ᵘ', 'v': 'ᵛ', 'w': 'ʷ', 'x': 'ˣ', 'y': 'ʸ', 'z': 'ᶻ',
        'A': 'ᴬ', 'B': 'ᴮ', 'C': 'ᶜ', 'D': 'ᴰ', 'E': 'ᴱ', 'F': 'ᶠ', 'G': 'ᴳ', 'H': 'ᴴ', 'I': 'ᴵ',
        'J': 'ᴶ', 'K': 'ᴷ', 'L': 'ᴸ', 'M': 'ᴹ', 'N': 'ᴺ', 'O': 'ᴼ', 'P': 'ᴾ', 'Q': 'ᑫ', 'R': 'ᴿ',
        'S': 'ˢ', 'T': 'ᵀ', 'U': 'ᵁ', 'V': 'ⱽ', 'W': 'ᵂ', 'X': 'ˣ', 'Y': 'ʸ', 'Z': 'ᶻ',
        '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹',
        '+': '⁺', '-': '⁻', '=': '⁼', '(': '⁽', ')': '⁾'
    };

    return text.split('').map(c => superscriptMap[c] || c).join('');
}
  
// Add transformation options to a select element
var TextMagiQ = {
    replaceText: {
        "Fontastic": async function(app, text) {
          const textWithFormatting = app.context.selectionContent;
            try {
                // Simulate user input for transformation type
                const result = await app.prompt("Select text transformation", {
                    inputs: [
                        {
                            label: "Select text transformation",
                            type: "select",
                            options: [
                                { label: "None", value: "" },
                                { label: "Case: Sentence case", value: "sentence_case" },
                                { label: "Case: UPPER CASE", value: "upper_case" },
                                { label: "Case: lower case", value: "lower_case" },
                                { label: "Case: Capitalized Case", value: "capitalized_case" },
                                { label: "Case: Title Case", value: "title_case" },
                                { label: "Case: aLtErNaTiNg CASE", value: "alternating_case" },
                                { label: "Case: lnVeRsE Case", value: "inverse_case" },
                              
                                { label: "Special: RanDom cAsE", value: "random_case" },
                                { label: "Special: Small Caps (Immutable)", value: "small_caps" },
                                { label: "Special: Superscript (Immutable)", value: "superscript2" },
                                { label: "Special: Wide Text (Immutable)", value: "wide_text" },
                              
                                { label: "Flip: Reverse Text", value: "reverse_text" },
                                { label: "Flip: Upside Down Text (Immutable)", value: "upside_down_text" },

                                { label: "Code: Text -> Morse Code", value: "morse_code_translate" },
                                { label: "Code: Morse Code -> Text", value: "morse_code_reverse" },
                                { label: "Code: Text -> Binary", value: "binary_translate" },
                                { label: "Code: Binary -> Text", value: "binary_reverse" },

                                { label: "Visual: Mirror Text", value: "mirror_text" },
                                { label: "Visual: Zalgo Text", value: "zalgo_text" },
                              
                                { label: "General: Bold", value: "bold" },
                                { label: "General: Italic", value: "italic" },
                                { label: "General: Strikethrough", value: "strikethrough" },
                                //{ label: "General: Underline", value: "underline" },
                                { label: "General: Block Quote", value: "blockquote" },
                                { label: "General: Literate Text", value: "code" },
                                //{ label: "General: Subscript", value: "subscript" },
                                //{ label: "General: Superscript", value: "superscript" },
                              
                                //{ label: "Unicode: Fraktur", value: "fraktur" },
                                //{ label: "Unicode: Fraktur (Bold) (Working Weird!)", value: "fraktur_bold" },
                              
                                //{ label: "Unicode: Squared (Working Weird!)", value: "squared" },
                                //{ label: "Unicode: Squared (Inverted) (Working Weird!)", value: "squared_inverted" },
                                { label: "Unicode: Circled", value: "circled" }
                                //,{ label: "Unicode: Circled (Inverted) (Working Weird!)", value: "circled_inverted" }
                            ]
                        }
                    ]
                });

                const textTransform = result; // Replace with actual user input or logic
                console.log("User Selection:", textTransform);
                console.log("MD Text:", textWithFormatting);
                console.log("Selected Text:", text);
                //const text = text;
                //const transformedText = transformText(text, textTransform);
                //const transformedText = transformText(textWithFormatting, textTransform);
                //alert("Transformed text:" + transformedText);

                if (textTransform === "bold" || textTransform === "italic" || textTransform === "strikethrough" || textTransform === "underline" || textTransform === "blockquote" || textTransform === "code" || textTransform === "subscript" || textTransform === "superscript") 
                {
					const transformedText = transformText(textWithFormatting, textTransform);
                    console.log("Result:", transformedText);
                    await app.context.replaceSelection(transformedText);
                    //return transformedText; // Return transformed text
                }
				else 
                {
					const transformedText = transformText(text, textTransform);
                    console.log("Result:", transformedText);
                    return transformedText; // Return transformed text
                }
                //return transformedText; // Return transformed text

            } catch (error) {
                alert(String(error));
                return text; // Return original text in case of error
            }
        }
    }
};

var plugin_default = TextMagiQ;
return TextMagiQ;

})()
```

---

## <mark style="color:#F8D616;">Additional Information:<!-- {"cycleColor":"25"} --></mark>

---

### <mark style="color:#F5614C;">**Change Log:**<!-- {"cycleColor":"23"} --></mark>

- July 17th, 2024 - Completed the basic framework of the code. Without Testing.

- July 18th, 2024 - Completed the Testing and found multiple Emoji Like Unicode's were not supported here! Not sure if the platform does not support or something is wrong with my code. Well for now having the raw code base still intact and commenting the code which bring user's visibility!

- July 30th, 2024 - Added Additional Options - Bold, Italic, Strikethrough, Block Quote, Literate Text (using app.context.selectionContent amplenote feature!)

---

### <mark style="color:#F5614C;">**Implemented & Upcoming:**<!-- {"cycleColor":"23"} --></mark>

- <mark style="color:#FFFFFF;">~~Capitalization~~<!-- {"cycleColor":"55"} --></mark> 

    - <mark style="color:#FFFFFF;">~~Sentence case < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~lower case < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~UPPER CASE < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Capitalized Case < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~aLtErNaTiNg CASE < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Title Case < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~lnVeRsE Case < Done !!~~<!-- {"cycleColor":"55"} --></mark>

- <mark style="color:#FFFFFF;">~~Generator~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Small Text Generator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Wide Text Generator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Strikethrough Text Generator  < Unsupported / In Dev !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Bold Text Generator   < Unsupported / In Dev !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Italic Text Converter   < Unsupported / In Dev !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Reverse Text Generator  < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Upside down Text Generator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Underline Text Generator   < Unsupported / In Dev !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Mirror Text Generator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Zalgo Glitch Text Generator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

- <mark style="color:#FFFFFF;">~~Translator~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Morse Code Translator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Binary Code Translator < Done !!~~<!-- {"cycleColor":"55"} --></mark>

    - <mark style="color:#FFFFFF;">~~Unicode Text Converter  < Unsupported / In Dev !!~~<!-- {"cycleColor":"55"} --></mark>

- General

    - ~~Bold, Italic, Strikethrough, Block Quote, Literate Text~~

<mark style="color:#9AD62A;">**Future Ideas in the Bucket:**<!-- {"cycleColor":"26"} --></mark>

- Aesthetic Font and text generator - (Having a Checkbox option, when checked it will implement these after converting the case or any modifications!) 

    - Curly quotes: These are curved quotation marks instead of straight ones (e.g., “ ” instead of " ").

    - Em dashes: Longer dashes used to indicate a break in thought or speech (e.g., —).

    - Ellipses: Three dots used to indicate omission or trailing off (e.g., ...).

    - Ligatures / Ligatures and Stylistic Sets: Combinations of two or more letters into a single glyph (e.g., æ, œ). 

    - **Enhanced Text Formatting**:

        - Enables the use of non-breaking spaces and other spacing control characters.

            - **Non-breaking Spaces**:

                - Prevents line breaks at specific points to keep elements together.

                - Example: Typing `Mr.\\ Smith` ensures "Mr." and "Smith" stay on the same line.

    - **Typographic Controls**:

        - Allows precise control over kerning, line height, and letter spacing.

        - Provides options for customizing font and style for different parts of the text.

    - **Special Characters and Symbols**:

        - Easy insertion of special characters and symbols such as ©, ™, or †.

        - Allows easy insertion of typographic symbols like ©, ™, ®, †, ‡, §, ¶.

        - Example: Typing \\copyright converts to ©.

    - Old-style numerals: These have ascenders and descenders like lowercase letters.

    - Ornaments: Decorative elements like swashes, dingbats, or rules.

    - Initial letters: Elaborate or decorated first letters of paragraphs or sections.

    - Letterspacing: Adjusting the space between letters for emphasis or visual balance.

    - Kerning: Adjusting the space between specific pairs of letters for improved appearance.

        - Visual Examples:

            - Typographic flourishes

            - Decorative typography

            - Typography examples

            - Classic typography

- [Future Plan - Amplenote Plugins!](https://www.amplenote.com/notes/78995798-3f78-11ef-9b28-26e37c279344) 

---

[TextMagiQ Code Docs](https://www.amplenote.com/notes/454afe70-44e9-11ef-bdf6-26e37c279344) For Curious Readers and Explores! Thank you if you have made till here. You are Awesome, if you are reading this! 😀. Have a Great Day Ahead!

---

Time Invested For this Plugin: 5h 43m + 8h 19m = Totaling up to 14h\~. \[Not including the ideas popping up randomly when doing daily rituals, only Screen Time.\]

---

1. [Welcome Note:](#Welcome_Note:) 

    1. [Initial Things TODO after installation: ](#Initial_Things_TODO_after_installation:_) 

    1. [Demo:](#Demo:) 

        1. [General - Calling the Plugin - TextMagiQ](#General_-_Calling_the_Plugin_-_TextMagiQ) 

    1. [Documentation:](#Documentation:) 

        1. [Text Transformation Utility Overview](#Text_Transformation_Utility_Overview) 

    1. [Transformation Types](#Transformation_Types) 

        1. [1. sentence_case](#1._sentence_case) 

        1. [2. lower_case](#2._lower_case) 

        1. [3. upper_case](#3._upper_case) 

        1. [4. capitalized_case](#4._capitalized_case) 

        1. [5. alternating_case](#5._alternating_case) 

        1. [6. title_case](#6._title_case) 

        1. [7. inverse_case](#7._inverse_case) 

        1. [8. random_case](#8._random_case) 

        1. [9. small_caps](#9._small_caps) 

        1. [10. superscript](#10._superscript) 

        1. [11. wide_text](#11._wide_text) 

        1. [12. reverse_text](#12._reverse_text) 

        1. [13. upside_down_text](#13._upside_down_text) 

        1. [14. morse_code_translate](#14._morse_code_translate) 

        1. [15. morse_code_reverse](#15._morse_code_reverse) 

        1. [16. binary_translate](#16._binary_translate) 

        1. [17. binary_reverse](#17._binary_reverse) 

        1. [18. mirror_text](#18._mirror_text) 

        1. [19. zalgo_text](#19._zalgo_text) 

        1. [20. circled](#20._circled) 

    1. [Table - Plugin Parameters:](#Table_-_Plugin_Parameters:) 

    1. [Code Base:](#Code_Base:) 

    1. [Additional Information:](#Additional_Information:) 

        1. [Change Log:](#Change_Log:) 

        1. [Implemented & Upcoming:](#Implemented_&_Upcoming:) 

---

\

 

\